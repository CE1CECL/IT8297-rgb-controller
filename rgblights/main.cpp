#if _WIN32
#include <conio.h>
#endif

#include <thread>
#include <chrono>
#include <iostream>
#include <cstdio>
#include <cstring>
#include <libusb.h>

template < typename T, size_t N >
constexpr size_t countof(T(&arr)[N])
{
	return N;
}

const uint16_t VID = 0x048D;
const uint16_t PID = 0x8297;

// As seen on Gigabyte X570 Elite board
const uint16_t HDR_D_LED1 = 0x2025; //really just 0x25, wtf is 0x20
const uint16_t HDR_D_LED2 = 0x4026; //really just 0x26, wtf is 0x40
const uint8_t HDR_D_LED1_RGB = 0x58;
const uint8_t HDR_D_LED2_RGB = 0x59;

/*
Device descriptor: 1812010002000000408d049782000101020001
String descriptor 0:
		''

String descriptor 1:
		''

String descriptor 2:
		''

Config descriptor 1: 09021b000101008032090400000003000000092110010001223615
bInterfaceNumber 0, bInterfaceClass 3
		HID report descriptor: 0689ff0910a1010903150025ff75089510b20201c0
		0x06, 0x89, 0xFF,  // Usage Page (Vendor Defined 0xFF89)
		0x09, 0x10,        // Usage (0x10)
		0xA1, 0x01,        // Collection (Application)
		0x09, 0x03,        //   Usage (0x03)
		0x15, 0x00,        //   Logical Minimum (0)
		0x25, 0xFF,        //   Logical Maximum (-1)
		0x75, 0x08,        //   Report Size (8)
		0x95, 0x10,        //   Report Count (16)
		0xB2, 0x02, 0x01,  //   Feature (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position,Non-volatile,Buffered Bytes)
		0xC0,              // End Collection
		// 21 bytes
*/

template<size_t buf_sz>
void dump(unsigned char (&buf)[buf_sz], int count)
{
	int i;
	// Dump results
	for (i = 0; i < count && i < (int)buf_sz; i++) {
		printf("%02x", buf[i]);
	}
	printf("\n");
}

unsigned char packet_cc6000[] = {
  0xcc, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// Commit? Another effect doesn't seem to start to play without this
unsigned char packet_commit_effect[] = {
  0xcc, 0x28, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

unsigned char packet_cc3100[] = {
  0xcc, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

unsigned char packet_play_effect[] = {
  0xcc, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

unsigned char packet_stop_effect[] = {
  0xcc, 0x32, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

unsigned char packet_cc3400[] = {
  0xcc, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

unsigned char packet_cc2001[] = {
  0xcc, 0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x02, 0x5a, 0x00, 0x00, 0x21,
  0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb0, 0x04,
  0xb0, 0x04, 0xf4, 0x01, 0x00, 0x00, 0x00, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

unsigned char packet_cc2102[] = {
  0xcc, 0x21, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x01, 0x64, 0x00, 0x00, 0x21,
  0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xb0, 0x04, 0xf4, 0x01, 0x00, 0x00, 0x00, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

unsigned char packet_cc2204[] = {
  0xcc, 0x22, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x01, 0x64, 0x00, 0x00, 0x21,
  0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xb0, 0x04, 0xf4, 0x01, 0x00, 0x00, 0x00, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

unsigned char packet_cc2308[] = {
  0xcc, 0x23, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x01, 0x64, 0x00, 0x00, 0x21,
  0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xb0, 0x04, 0xf4, 0x01, 0x00, 0x00, 0x00, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

unsigned char packet_cc2410[] = {
  0xcc, 0x24, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x01, 0x64, 0x00, 0x83, 0xcc,
  0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xb0, 0x04, 0xf4, 0x01, 0x00, 0x00, 0x00, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

unsigned char packet_static_0000FF[] = {
  0xcc, 0x25, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x01, 0x32, 0x00, 0x00, 0x00,
  0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xee, 0x02, 0xf4, 0x01, 0x00, 0x00, 0x07, 0x01,
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

unsigned char packet_static_F000FF[] = {
  0xcc, 0x25, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x01, 0x32, 0x00, 0xf0, 0x00,
  0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xee, 0x02, 0xf4, 0x01, 0x00, 0x00, 0x07, 0x01,
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

unsigned char packet_static_orange[] = {
  0xcc, 0x25, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x01, 0x64, 0x00, 0x00, 0x21,
  0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xee, 0x02, 0xf4, 0x01, 0x00, 0x00, 0x07, 0x01,
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

//FF2100 double flash ~40 % speed
unsigned char packet_double_flash_40[] = {
  0xcc,
  0x25, 0x20, // bottom header
  0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x03, 0x64, 0x00, 0x00, 0x21,
  0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00,
  0x64, 0x00, 0x98, 0x08, 0x00, 0x00, 0x00, 0x01,
  0x06 /* flash count */, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

unsigned char packet_pulse_FF2100_upper[] = {
  0xcc,
  0x26, 0x40, // upper header
  0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x02, 0x5a, 0x00, 0x00, 0x21,
  0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb0, 0x04,
  0xb0, 0x04, 0xf4, 0x01, 0x00, 0x00, 0x00, 0x01,
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

unsigned char packet_pulse_FF2100_bottom[] = {
  0xcc,
  0x25, 0x20, // bottom header
  0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x02, 0x5a, 0x00, 0x00, 0x10,
  0xFF, 0x00, 0x00, 0x00, 0x21, 0x00,
  0x40, 0x07, //fade in period
  0xb0, 0x07, // fade out period
  0x04, 0x01, // hold period
  0x00, 0x00, 0x00, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

unsigned char packet_colorcycle_100[] = {
  0xcc, 0x25, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x04, 0x32, 0x00, 0x00, 0x00,
  0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcc, 0x01,
  0x68, 0x01, 0xf4, 0x01, 0x00, 0x00, 0x07, 0x01,
  0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

unsigned char packet_colorcycle_0[] = {
  0xcc, 0x25, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x04, 0x64, 0x00, 0x00, 0x00,
  0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x05,
  0xb0, 0x04, 0xf4, 0x01, 0x00, 0x00, 0x07, 0x01,
  0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

unsigned char packet_colorcycle_0_bright[] = {
	0xcc, 0x25, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x04, 0x0f, 0x00, 0x00, 0x00,
	0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x04,
	0x1a, 0x04, 0xf4, 0x01, 0x00, 0x00, 0x07, 0x01,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

class UsbDevice
{
public:
	virtual void Init() = 0;
	virtual int SendPacket(unsigned char *packet) = 0;
};

class UsbIT8297 : public UsbDevice
{
public:
	UsbIT8297()
	{
	}

	void Init()
	{
		libusb_init(&ctx);

		handle = libusb_open_device_with_vid_pid(nullptr, 0x048D, 0x8297);

		if (!handle)
			throw std::exception("Failed to open device");

		int res = libusb_claim_interface(handle, 0);
		if (res != LIBUSB_SUCCESS)
			throw std::exception("Failed to claim interface 0");


		// Most of the start up sequence as RGB Fusion does it
		res = SendPacket(packet_cc6000);

		// get some HID report, should contain ITE stuff
		// FIXME libusb _hid_get_report over allocates buffer and IT8297 no likey
		//res = libusb_control_transfer(handle, 0x21 | LIBUSB_ENDPOINT_IN, 0x01, 0x03CC, 0x0000, buffer, 64, 1000);
		//if (res > 0) // max 32 byte string?
		//	std::cout << "Device: " << (buffer + 12) << std::endl;

		res = SendPacket(packet_cc3400);
		res = SendPacket(packet_cc3100);
		res = SendPacket(packet_cc2001);
		res = SendPacket(packet_cc3100);
		res = SendPacket(packet_cc2102);
		res = SendPacket(packet_cc3100);
		res = SendPacket(packet_cc2204);
		res = SendPacket(packet_cc3100);
		res = SendPacket(packet_cc2308);
		res = SendPacket(packet_cc3100);
		res = SendPacket(packet_cc2410);
		//res = SendPacket(packet_cc3100);
	}

	~UsbIT8297()
	{
		if (ctx)
		{
			int res = libusb_release_interface(handle, 0);
			libusb_close(handle);
			libusb_exit(ctx);
			ctx = nullptr;
		}
	}

	int SendPacket(unsigned char *packet)
	{
		return libusb_control_transfer(handle, 0x21, 0x09, 0x03CC, 0x0000, packet, 64, 1000);
	}

private:
	struct libusb_device_handle *handle = nullptr;
	struct libusb_context *ctx = nullptr;
};

struct RGBBytes
{
	uint8_t g;
	uint8_t r;
	uint8_t b;
};

union PktRGB
{
	unsigned char buffer[64];
	struct RGBData
	{
		uint8_t cc;// = 0xCC;
		uint8_t header;// = 0x58 - lower header, 0x59 - upper header;
		uint16_t boffset;// = 0; // in bytes, absolute
		uint8_t  bcount;// = 0;
		RGBBytes leds[19];
		uint16_t padding0;
	} s;

	PktRGB()
	{
		Reset();
	}

	void Reset()
	{
		s.cc = 0xCC;
		s.header = HDR_D_LED1_RGB; //sending as 0x53, or was it 0x54, screws with color cycle effect
		s.boffset = 0;
		s.bcount = 0;
		memset(s.leds, 0, sizeof(s.leds));
	}
};


void DoRGB(UsbDevice& usbDevice)
{
	int res;
	PktRGB packet;

	int delay_ms = 100;
	int led_offset = 0;

	//for (int j = 0; j < 5000 / delay_ms; j++) // per 5 seconds or sumfin
	for (int j = 0; j < 8; j++)
	{
		//for (int i = 0; i < countof(packet_bytes); i++)
		{

			int all_leds = 32; //deemit, hope it is a bug that it only shows groups of 32 leds :(
			int left_leds = all_leds;
			int leds = countof(packet.s.leds);
			int sent_data = 0;
			int k = 0;

			while (left_leds > 0) {
				packet.Reset();
				leds = min(leds, left_leds);
				left_leds -= leds;

				packet.s.bcount = leds * 3;
				packet.s.boffset = sent_data;
				sent_data += packet.s.bcount;

				/*for (int i = 0; i < leds; i++) {

					packet.s.leds[i].g = ((255 - (i * 0xFF / all_leds) + 1) + j*3) % 256; //G
					packet.s.leds[i].r = 255 - packet.s.leds[i].g; //R
					packet.s.leds[i].b = 0;// (packet.s.leds[i].r * packet.s.leds[i].g) % 32; //B
				}*/

				for (int i = 0; i < leds; i++) {
					if (led_offset == k) {
						packet.s.leds[i].r = 0x0F;
						std::cout << "set led @ " << led_offset << std::endl;
					}
					else if (led_offset == k + 1)
						packet.s.leds[i].g = 0x0F;
					else if (led_offset == k + 2)
						packet.s.leds[i].b = 0x0F;
					k++;
				}

				std::cout << "led offset " << (int)packet.s.boffset << ":" << (int)packet.s.bcount << std::endl;
				res = usbDevice.SendPacket(packet.buffer);
				if (res < 0) {
					std::cerr << "error: " << res << std::endl;
					return;
				}
			}

			led_offset = (led_offset + 1) % all_leds;
			std::this_thread::sleep_for(std::chrono::milliseconds(delay_ms));

			std::cout << "line " << j << std::endl;
		}
	}
}


int main()
{
	UsbIT8297 ite;
	int res;
	struct libusb_device_handle *handle;
	unsigned char buffer[65];
	memset(buffer, 0, sizeof(buffer));

	try
	{
		ite.Init();
	}
	catch (std::exception &ex)
	{
		std::cerr << ex.what() << std::endl;
		return 1;
	}

	//res = ite.SendPacket(packet_cc3100);
	res = ite.SendPacket(packet_stop_effect);

	DoRGB(ite);

	std::cerr << "\n\n\nclear leds" << std::endl;

	res = ite.SendPacket(packet_play_effect);

	//res = ite.SendPacket(packet_cc3400);
	res = ite.SendPacket(packet_cc3100);

	res = ite.SendPacket(packet_static_0000FF);
	res = ite.SendPacket(packet_commit_effect);

	res = ite.SendPacket(packet_colorcycle_100);
	//res = ite.SendPacket(packet_double_flash_40);
	//res = ite.SendPacket(packet_pulse_FF2100_bottom);
	
	res = ite.SendPacket(packet_commit_effect);

#if _WIN32
	std::cerr << "\n\n\nPress enter to exit" << std::endl;
	//if (res < 0)
		_getch();
#endif
	return 0;
}
